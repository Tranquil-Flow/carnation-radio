'use strict';

var url = require('url');
var bindings = require('bindings');
var debug = require('debug');
var stream = require('stream');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
const moduleRoot = bindings.getRoot(url.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.src || new URL('index.cjs', document.baseURI).href))));
const {
  _testAsync,
  napiVersion,
  EncoderBuilder,
  Encoder,
  DecoderBuilder,
  Decoder,
  format,
  metadata,
  metadata0,
  SimpleIterator,
  Chain,
  Iterator,
  fns,
} = bindings({ bindings: 'flac-bindings.node', module_root: moduleRoot });

var api = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Chain: Chain,
  Decoder: Decoder,
  DecoderBuilder: DecoderBuilder,
  Encoder: Encoder,
  EncoderBuilder: EncoderBuilder,
  Iterator: Iterator,
  SimpleIterator: SimpleIterator,
  _testAsync: _testAsync,
  fns: fns,
  format: format,
  metadata: metadata,
  metadata0: metadata0,
  napiVersion: napiVersion
});

class BaseEncoder {
  /**
   * Stores all options in the object
   * @param {import('./interfaces').EncoderOptions} options Object of options
   * @param {(enc: EncoderBuilder) => Promise<Encoder>} initEncoder
   * @param {(enc: EncoderBuilder) => Promise<Encoder>} initOggEncoder
   * @param {import('debug').Debugger} debug
   */
  constructor(options, initEncoder, initOggEncoder, debug) {
    this._processedSamples = 0;
    this._storedChunks = [];

    // default values
    this._channels = 2;
    this._bitsPerSample = 16;
    this._builder = new EncoderBuilder()
      .setChannels(2)
      .setBitsPerSample(16)
      .setSampleRate(44100);

    this._initEncoder = initEncoder;
    this._initOggEncoder = initOggEncoder;
    this._debug = debug;

    this.setOptionsToEncoder(options);
  }

  get processedSamples() {
    return this._processedSamples
  }

  getState() {
    return (this._enc || this._builder).getState()
  }

  /**
   * Converts the buffer to int32_t if necessary
   * @param {Buffer} inputChunk A chunk of data
   * @returns {Buffer} converted buffer
   */
  convertToInt32Buffer(inputChunk) {
    if (this._inputAs32) {
      return inputChunk
    }

    const inBps = this._bitsPerSample / 8;
    let chunk = inputChunk;
    if (this._storedChunks.length > 0) {
      chunk = Buffer.concat([...this._storedChunks, inputChunk]);
      this._storedChunks = [];
    }

    const samples = Math.trunc(chunk.length / inBps / this._channels);
    const buffer = fns.convertSampleFormat({
      inBps,
      buffer: chunk,
      samples: samples * this._channels,
    });

    if (samples !== chunk.length / inBps / this._channels) {
      const extraBytes = chunk.length - (samples * inBps * this._channels);
      const remainingBuffer = Buffer.allocUnsafe(extraBytes);
      chunk.copy(remainingBuffer, 0, samples * inBps * this._channels);
      this._storedChunks.push(remainingBuffer);
      this._debug(`There are extra bytes which will be stored for the next process (${remainingBuffer.length})`);
    }

    return buffer
  }

  /**
   * Sets the options to the encoder
   * @param {import('./interfaces').EncoderOptions} options Object of options
   */
  setOptionsToEncoder(options) {
    this._debug('setOptionsToEncoder()');

    this._inputAs32 = options.inputAs32 || options.is32bit || false;

    if (options.isOggStream != null) {
      this._oggStream = !!options.isOggStream;
      if (this._oggStream && !format.API_SUPPORTS_OGG_FLAC) {
        throw new Error('Ogg FLAC is unsupported')
      }
    }

    if (this._oggStream && options.oggSerialNumber) {
      this._builder.setOggSerialNumber(options.oggSerialNumber);
    }

    if (options.channels) {
      this._builder.setChannels(options.channels);
      this._channels = options.channels;
    }

    const bps = options.bitsPerSample || options.bitDepth;
    if (bps) {
      this._builder.setBitsPerSample(bps);
      this._bitsPerSample = this._inputAs32 ? 32 : bps;
    }

    const sampleRate = options.sampleRate || options.samplerate;
    if (sampleRate) {
      this._builder.setSampleRate(sampleRate);
    }

    if (options.totalSamplesEstimate != null) {
      this._builder.setTotalSamplesEstimate(options.totalSamplesEstimate);
    }

    if (options.compressionLevel != null) {
      this._builder.setCompressionLevel(options.compressionLevel);
    } else {
      if (options.doMidSideStereo !== null) {
        this._builder.setDoMidSideStereo(options.doMidSideStereo);
      }
      if (options.looseMidSideStereo !== null) {
        this._builder.setLooseMidSideStereo(options.looseMidSideStereo);
      }
      if (options.apodization) {
        this._builder.setApodization(options.apodization);
      }
      if (options.maxLpcOrder != null) {
        this._builder.setMaxLpcOrder(options.maxLpcOrder);
      }
      if (options.qlpCoeffPrecision != null) {
        this._builder.setQlpCoeffPrecision(options.qlpCoeffPrecision);
      }
      if (options.doQlpCoeffPrecSearch != null) {
        this._builder.setDoQlpCoeffPrecSearch(options.doQlpCoeffPrecSearch);
      }
      if (options.doExhaustiveModelSearch != null) {
        this._builder.setDoExhaustiveModelSearch(options.doExhaustiveModelSearch);
      }
      if (options.minResidualPartitionOrder != null) {
        this._builder.setMinResidualPartitionOrder(options.minResidualPartitionOrder);
      }
      if (options.maxResidualPartitionOrder != null) {
        this._builder.setMaxResidualPartitionOrder(options.maxResidualPartitionOrder);
      }
    }

    if (options.blocksize != null) {
      this._builder.setBlocksize(options.blocksize);
    }

    if (Array.isArray(options.metadata)) {
      this._builder.setMetadata(options.metadata);
    }
  }

  /**
   * Process a chunk of data through the encoder
   * @param {Buffer} chunk A chunk of data
   * @param {(err?: any) => void} callback Callback to notify end of process
   */
  async processChunk(chunk, callback) {
    try {
      if (!this._enc) {
        try {
          if (this._oggStream) {
            this._debug('Initializing encoder with Ogg');
            this._enc = await this._initOggEncoder(this._builder);
          } else {
            this._debug('Initializing encoder');
            this._enc = await this._initEncoder(this._builder);
          }
        } catch (error) {
          const initStatus = error.status || -1;
          const initStatusString = error.statusString || 'Unknown';
          this._debug(`Failed initializing encoder: ${initStatus} ${initStatusString}`);
          throw error
        }
      }

      const chunkToProcess = this.convertToInt32Buffer(chunk);
      const samples = Math.trunc(chunkToProcess.length / this._channels / 4);
      this._processedSamples += samples;
      this._debug(`Received ${samples} samples (${chunkToProcess.length} bytes) to be processed`);

      if (!(await this._enc.processInterleavedAsync(chunkToProcess, samples))) {
        const err = this._enc.getState();
        const errStr = Encoder.StateString[err];
        this._debug(`Process received samples failed: ${errStr} [${err}]`);
        throw new Error(errStr)
      } else {
        callback(null);
      }
    } catch (e) {
      callback(e);
    }
  }

  /**
   * Finalize the encoding process by flushing the encoder.
   * @param {(err?: any) => void} callback Callback to notify end of process
   */
  async finishEncoder(callback) {
    try {
      if (!this._enc) {
        this._debug('Encoder did not receive any data and it is being finalized');
        callback(null);
        return
      }

      if (this._storedChunks.length > 0) {
        const chunk = Buffer.concat(this._storedChunks);
        this._storedChunks = [];
        this._debug('Processing final samples');
        await this.processChunk(chunk, (err) => {
          if (err) {
            throw err
          }
        });
      }

      this._debug('Flushing encoder');
      if (!(await this._enc.finishAsync())) {
        const err = this._enc.getState();
        const errStr = Encoder.StateString[err];
        this._debug(`Flush encoder failed: ${errStr} [${err}]`);
        throw new Error(errStr)
      }

      callback(null);
    } catch (e) {
      callback(e);
    }
  }
}

class FileEncoder extends stream.Writable {
  constructor(options = {}) {
    super({ ...options, decodeStrings: true });
    this._debug = debug('flac:encoder:file');
    if (!options.file) {
      throw new Error('No file passed as argument')
    }

    this._baseEncoder = new BaseEncoder(
      options,
      (builder) => builder.buildWithFileAsync(options.file, null),
      (builder) => builder.buildWithOggFileAsync(options.file, null),
      this._debug,
    );

    this._format = this._format.bind(this);
    this.on('pipe', (src) => {
      this._baseEncoder.setOptionsToEncoder(src);
      src.once('format', this._format);
    });
    this.on('unpipe', (src) => {
      src.removeListener('format', this._format);
    });
  }

  get processedSamples() {
    return this._baseEncoder.processedSamples
  }

  getState() {
    return this._baseEncoder.getState()
  }

  _write(chunk, _, callback) {
    return this._baseEncoder.processChunk(chunk, callback)
  }

  _final(callback) {
    return this._baseEncoder.finishEncoder(callback)
  }

  _format(format) {
    this._baseEncoder.setOptionsToEncoder(format);
  }
}

class StreamEncoder extends stream.Transform {
  constructor(options = {}) {
    super({
      ...options,
      decodeStrings: false,
      defaultEncoding: undefined,
      encoding: undefined,
    });
    this._debug = debug('flac:encoder:stream');
    this._baseEncoder = new BaseEncoder(
      options,
      (builder) => builder.buildWithStreamAsync(this._writeFlac.bind(this), null, null, null),
      (builder) => (
        builder.buildWithOggStreamAsync(null, this._writeFlac.bind(this), null, null, null)
      ),
      this._debug,
    );

    this._format = this._format.bind(this);
    this.on('pipe', (src) => {
      this._baseEncoder.setOptionsToEncoder(src);
      src.once('format', this._format);
    });
    this.on('unpipe', (src) => {
      src.removeListener('format', this._format);
    });
  }

  get processedSamples() {
    return this._baseEncoder.processedSamples
  }

  getState() {
    return this._baseEncoder.getState()
  }

  _transform(chunk, _, callback) {
    return this._baseEncoder.processChunk(chunk, callback)
  }

  _flush(callback) {
    return this._baseEncoder.finishEncoder(callback)
  }

  _writeFlac(buffer) {
    const buffer2 = Buffer.from(buffer);
    this.push(buffer2);
    this._debug(`Received ${buffer2.length} bytes of encoded flac data`);
    return Encoder.WriteStatus.OK
  }

  _format(format) {
    this._baseEncoder.setOptionsToEncoder(format);
  }
}

/* eslint-disable no-await-in-loop */

class FileDecoder extends stream.Readable {
  constructor(options = {}) {
    super(options);
    this._debug = debug('flac:decoder:file');
    this._builder = new DecoderBuilder();
    this._dec = undefined;
    this._oggStream = options.isOggStream || false;
    this._outputAs32 = options.outputAs32 || false;
    this._file = options.file;
    this._processedSamples = 0;
    this._failed = false;

    if (!this._file) {
      throw new Error('No file passed as argument')
    }

    if (this._oggStream && !format.API_SUPPORTS_OGG_FLAC) {
      throw new Error('Ogg FLAC is unsupported')
    }

    if (options.metadata === true) {
      this._debug('Setting decoder to emit all metadata blocks');
      this._builder.setMetadataRespondAll();
    } else if (Array.isArray(options.metadata)) {
      this._debug(`Setting decoder to emit '${options.metadata.join(', ')}' metadata blocks`);
      for (const type of options.metadata) {
        this._builder.setMetadataRespond(type);
      }
    }
  }

  get processedSamples() {
    return this._processedSamples
  }

  getTotalSamples() {
    if (this._totalSamples === undefined) {
      this._totalSamples = this._dec.getTotalSamples();
    }
    return this._totalSamples
  }

  getChannels() {
    if (this._channels === undefined) {
      this._channels = this._dec.getChannels();
    }
    return this._channels
  }

  getChannelAssignment() {
    if (this._channelAssignment === undefined) {
      this._channelAssignment = this._dec.getChannelAssignment();
    }
    return this._channelAssignment
  }

  getBitsPerSample() {
    if (this._bitsPerSample === undefined) {
      this._bitsPerSample = this._dec.getBitsPerSample();
    }
    return this._bitsPerSample
  }

  getOutputBitsPerSample() {
    if (this._outputAs32) {
      return 32
    }

    return this.getBitsPerSample()
  }

  getSampleRate() {
    if (this._sampleRate === undefined) {
      this._sampleRate = this._dec.getSampleRate();
    }
    return this._sampleRate
  }

  getProgress() {
    if (this._dec || (this._totalSamples && this._sampleRate)) {
      const position = this._processedSamples;
      const totalSamples = this.getTotalSamples();
      const percentage = totalSamples ? position / totalSamples : NaN;
      const totalSeconds = totalSamples ? totalSamples / this.getSampleRate() : NaN;
      const currentSeconds = position / this.getSampleRate();
      return {
        position,
        totalSamples,
        percentage,
        totalSeconds,
        currentSeconds,
      }
    }

    return undefined
  }

  _read() {
    if (!this._readLoopPromise) {
      this._readLoopPromise = this._readLoop().then(() => {
        if (this.readableLength === 0 && !this.destroyed) {
          this._read();
        }
      });
    }
  }

  async _readLoop() {
    try {
      if (this._dec === undefined) {
        this._debug('Initializing decoder');
        try {
          if (this._oggStream) {
            this._debug('Initializing for Ogg/FLAC');
            this._dec = await this._builder.buildWithOggFileAsync(
              this._file,
              this._writeCbk.bind(this),
              this._metadataCbk.bind(this),
              this._errorCbk.bind(this),
            );
          } else {
            this._debug('Initializing for FLAC');
            this._dec = await this._builder.buildWithFileAsync(
              this._file,
              this._writeCbk.bind(this),
              this._metadataCbk.bind(this),
              this._errorCbk.bind(this),
            );
          }
        } catch (error) {
          const initStatus = error.status || -1;
          const initStatusString = error.statusString || 'Unknown';
          this._debug(`Failed initializing decoder: ${initStatus} ${initStatusString}`);
          throw error
        }
      }

      this._debug('Wants data from decoder');
      while (!this.destroyed && this._dec != null) {
        const couldProcess = await this._dec.processSingleAsync();
        const decState = this._dec.getState();
        if (decState === Decoder.State.END_OF_STREAM) {
          this._debug('Decoder reached EOF -> flushing decoder and finishing stream');
          await this._dec.finishAsync();
          this.push(null);
          this._dec = null;
        } else if (!couldProcess && !this.destroyed) {
          this._throwDecoderError();
          return
        }
      }
    } catch (e) {
      this.destroy(e);
    }

    this._readLoopPromise = null;
  }

  _writeCbk(frame, buffers) {
    const outBps = this.getOutputBitsPerSample() / 8;
    const buff = fns.zipAudio({ samples: frame.header.blocksize, outBps, buffers });

    this._processedSamples += frame.header.blocksize;
    this.push(buff);
    this._debug(`Received ${frame.header.blocksize} samples (${buff.length} bytes) of decoded data`);

    return Decoder.WriteStatus.CONTINUE
  }

  _metadataCbk(metadata) {
    if (metadata.type === format.MetadataType.STREAMINFO) {
      this.emit('format', {
        channels: metadata.channels,
        bitDepth: metadata.bitsPerSample,
        bitsPerSample: metadata.bitsPerSample,
        is32bit: this._outputAs32,
        sampleRate: metadata.sampleRate,
        totalSamples: metadata.totalSamples,
      });
      this._totalSamples = metadata.totalSamples;
      this._channels = metadata.channels;
      this._bitsPerSample = metadata.bitsPerSample;
      this._sampleRate = metadata.sampleRate;
    }

    this.emit('metadata', metadata);
  }

  _errorCbk(code) {
    const message = Decoder.ErrorStatusString[code];
    this._debug(`Decoder called error callback ${code} (${message})`);
    this.emit('flac-error', { code, message });
  }

  _throwDecoderError() {
    const error = this._dec.getState();
    const errorObj = new Error(this._dec.getResolvedStateString());
    this._debug(`Decoder call failed: ${this._dec.getResolvedStateString()} [${error}]`);
    errorObj.code = error;
    throw errorObj
  }
}

/* eslint-disable no-await-in-loop */

class StreamDecoder extends stream.Transform {
  constructor(options = {}) {
    super({
      ...options,
      decodeStrings: false,
      defaultEncoding: undefined,
      encoding: undefined,
    });
    this._debug = debug('flac:decoder:stream');
    this._builder = new DecoderBuilder();
    this._dec = null;
    this._oggStream = options.isOggStream || false;
    this._outputAs32 = options.outputAs32 || false;
    this._chunks = [];
    this._processedSamples = 0;

    if (this._oggStream && !format.API_SUPPORTS_OGG_FLAC) {
      throw new Error('Ogg FLAC is unsupported')
    }

    if (options.metadata === true) {
      this._debug('Setting decoder to emit all metadata blocks');
      this._builder.setMetadataRespondAll();
    } else if (Array.isArray(options.metadata)) {
      this._debug(`Setting decoder to emit '${options.metadata.join(', ')}' metadata blocks`);
      for (const type of options.metadata) {
        this._builder.setMetadataRespond(type);
      }
    }
  }

  get processedSamples() {
    return this._processedSamples
  }

  getTotalSamples() {
    if (this._totalSamples === undefined) {
      this._totalSamples = this._dec.getTotalSamples();
    }
    return this._totalSamples
  }

  getChannels() {
    if (this._channels === undefined) {
      this._channels = this._dec.getChannels();
    }
    return this._channels
  }

  getChannelAssignment() {
    if (this._channelAssignment === undefined) {
      this._channelAssignment = this._dec.getChannelAssignment();
    }
    return this._channelAssignment
  }

  getBitsPerSample() {
    if (this._bitsPerSample === undefined) {
      this._bitsPerSample = this._dec.getBitsPerSample();
    }
    return this._bitsPerSample
  }

  getOutputBitsPerSample() {
    if (this._outputAs32) {
      return 32
    }

    return this.getBitsPerSample()
  }

  getSampleRate() {
    if (this._sampleRate === undefined) {
      this._sampleRate = this._dec.getSampleRate();
    }
    return this._sampleRate
  }

  getProgress() {
    if (this._dec || (this._totalSamples && this._sampleRate)) {
      const position = this._processedSamples;
      const totalSamples = this.getTotalSamples();
      const percentage = totalSamples ? position / totalSamples : NaN;
      const totalSeconds = totalSamples ? totalSamples / this.getSampleRate() : NaN;
      const currentSeconds = position / this.getSampleRate();
      return {
        position,
        totalSamples,
        percentage,
        totalSeconds,
        currentSeconds,
      }
    }

    return undefined
  }

  async _transform(chunk, _, callback) {
    try {
      if (!this._dec) {
        this._debug('Initializing decoder');
        try {
          if (this._oggStream) {
            this._debug('Initializing for Ogg/FLAC');
            this._dec = await this._builder.buildWithOggStreamAsync(
              this._readCbk.bind(this),
              null,
              null,
              null,
              null,
              this._writeCbk.bind(this),
              this._metadataCbk.bind(this),
              this._errorCbk.bind(this),
            );
          } else {
            this._debug('Initializing for FLAC');
            this._dec = await this._builder.buildWithStreamAsync(
              this._readCbk.bind(this),
              null,
              null,
              null,
              null,
              this._writeCbk.bind(this),
              this._metadataCbk.bind(this),
              this._errorCbk.bind(this),
            );
          }
        } catch (error) {
          const initStatus = error.status || -1;
          const initStatusString = error.statusString || 'Unknown';
          this._debug(`Failed initializing decoder: ${initStatus} ${initStatusString}`);
          throw error
        }
      }

      this._debug(`Received ${chunk.length} bytes to process`);
      this._chunks.push(chunk);
      while (!this._chunksIsAlmostEmpty() && this._dec !== null) {
        // a processSingle needs data, and have received enough, so it is time to unblock
        if (this._fillUpPause) {
          this._debug('Another processSingle call is blocked and there is enough data -> unblocking');
          this._fillUpPause();
          callback();
          return
        }
        // if the processSingle blocked did not finished yet, just don't do anything
        if (this._readCallback) {
          this._debug('Another processSingle call did not finished yet, doing nothing with this');
          callback();
          return
        }

        // flag to know if the next processSingle call has been blocked
        this._hasBeenBlocked = false;
        this._lastBytesDemanded = 0;
        // store the current callback just in case it gets blocked
        this._readCallback = callback;
        this._debug('Processing data');
        if (!(await this._dec.processSingleAsync())) {
          this._throwDecoderError();
          return
        }
        this._readCallback = null;

        // if the call has been blocked, then it does not need to do anything else
        if (this._hasBeenBlocked) {
          this._debug('processSingle was blocked, stopping loop for this processing');
          return
        }

        // avoid values of 0 bytes, by using a default value
        this._lastBytesDemanded = this._lastBytesDemanded || this._dec.getBlocksize() || 1024 * 32;
      }
      callback();
    } catch (e) {
      callback(e);
    }
  }

  async _flush(callback) {
    try {
      if (!this._dec) {
        this._debug('Decoder did not receive any data and it is being finalized');
        callback(null);
        return
      }

      this._timeToDie = true;
      if (this._chunks.length > 0) {
        this._debug('Processing final chunks of data');
        if (!(await this._dec.processUntilEndOfStreamAsync())) {
          this._throwDecoderError();
          return
        }
      }

      this._debug('Flushing decoder');
      if (!(await this._dec.finishAsync())) {
        this._throwDecoderError();
      }

      callback(null);
    } catch (e) {
      callback(e);
    }
  }

  _writeCbk(frame, buffers) {
    const outBps = this.getOutputBitsPerSample() / 8;
    const buff = fns.zipAudio({ samples: frame.header.blocksize, outBps, buffers });

    this._processedSamples += frame.header.blocksize;
    this.push(buff);
    this._debug(`Received ${frame.header.blocksize} samples (${buff.length} bytes) of decoded data`);

    return Decoder.WriteStatus.CONTINUE
  }

  _readCbk(buffer) {
    if (this._chunks.length > 0) {
      const b = this._chunks[0];
      const bytesRead = b.copy(buffer, 0);
      if (bytesRead === b.length) {
        this._chunks = this._chunks.slice(1);
      } else {
        this._chunks[0] = b.slice(bytesRead);
      }
      this._lastBytesDemanded += buffer.length;
      this._debug(`Read ${bytesRead} bytes from stored chunks to be decoded`);
      return { bytes: bytesRead, returnValue: Decoder.ReadStatus.CONTINUE }
    }

    if (this._timeToDie) {
      this._debug('Wanted to read, but the stream is being finished -> returning EOF');
      return { bytes: 0, returnValue: Decoder.ReadStatus.END_OF_STREAM }
    }

    this._debug(`There is no chunks of data to be read (wanted ${buffer.length}) -> blocking processSingle`);
    // there is not enough data: block the processSingle
    //   1. store the required bytes
    this._lastBytesDemanded = buffer.length;
    //   2. copy the callback
    const cbk = this._readCallback;
    //   3. notify that processSingle has been blocked
    this._hasBeenBlocked = true;
    //   4. block
    return new Promise((resolve) => {
      this._fillUpPause = () => {
        resolve({ bytes: 0, returnValue: Decoder.ReadStatus.CONTINUE });
        this._fillUpPause = undefined;
      };

      if (cbk) {
        // call the readCallback here
        cbk();
      }
    })
  }

  _metadataCbk(metadata) {
    if (metadata.type === format.MetadataType.STREAMINFO) {
      this.emit('format', {
        channels: metadata.channels,
        bitDepth: metadata.bitsPerSample,
        bitsPerSample: metadata.bitsPerSample,
        is32bit: this._outputAs32,
        sampleRate: metadata.sampleRate,
        totalSamples: metadata.totalSamples,
      });
      this._totalSamples = metadata.totalSamples;
      this._channels = metadata.channels;
      this._bitsPerSample = metadata.bitsPerSample;
      this._sampleRate = metadata.sampleRate;
    }

    this.emit('metadata', metadata);
  }

  _errorCbk(code) {
    const message = Decoder.ErrorStatusString[code];
    this._debug(`Decoder called error callback ${code} (${message})`);
    this.emit('flac-error', { code, message });
  }

  _throwDecoderError() {
    const error = this._dec.getState();
    const errorObj = new Error(this._dec.getResolvedStateString());
    this._debug(`Decoder call failed: ${this._dec.getResolvedStateString()} [${error}]`);
    errorObj.code = error;
    throw errorObj
  }

  _chunksIsAlmostEmpty() {
    if (this._lastBytesDemanded !== undefined) {
      return this._chunks.reduce((r, v) => r + v.length, 0) < this._lastBytesDemanded * 2
    }
    return this._chunks.length < 2
  }
}

exports.FileDecoder = FileDecoder;
exports.FileEncoder = FileEncoder;
exports.StreamDecoder = StreamDecoder;
exports.StreamEncoder = StreamEncoder;
exports.api = api;
